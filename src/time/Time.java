package time;

import java.awt.Point;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

import javax.swing.JOptionPane;

import action.LoginAction;
import Main.Card;
import Main.CardType;
import Main.Model;
import play.Playing;
import util.FileUtil;
import util.PlayUtil;

/**
 * AI
 * @author huzhp
 *
 */
public class Time extends Thread{
	public Playing palying;
	private boolean isRun = true;
	int i = 10;
	private String users;
	private Properties scorePro;
	private File scorefile;

	public Time(Playing play, int i) {
		this.palying = play;
		this.i = i;
	}
	
	/**
	 * 开始抢地主
	 */
	@Override
	public void run() {
		while (i > -1 && isRun()) {
			palying.time[1].setText("倒计时:" + i--);
			second(1);// 等一秒
		}
		if (i == -1)// 正常终结，说明超时
			palying.time[1].setText("不抢");
		palying.landlord[0].setVisible(false);
		palying.landlord[1].setVisible(false);
		for (Card card2 : palying.playerList[1])
			card2.canClick = true;// 可被点击
		// 如果自己抢到地主
		if (palying.time[1].getText().equals("抢地主")) {
			// 得到地主牌
			palying.playerList[1].addAll(palying.lordList);
			openlord(true);
			second(3);// 等待3秒
			PlayUtil.order(palying.playerList[1]);
			PlayUtil.rePosition(palying, palying.playerList[1], 1);
			setlord(1);
		} else {
			// 电脑选地主
			if (PlayUtil.getScore(palying.playerList[0]) < PlayUtil
					.getScore(palying.playerList[2])) {
				palying.time[2].setText("抢地主");
				palying.time[2].setVisible(true);
				setlord(2);// 设定地主
				openlord(true);
				second(3);
				palying.playerList[2].addAll(palying.lordList);
				PlayUtil.order(palying.playerList[2]);
				PlayUtil.rePosition(palying, palying.playerList[2], 2);
				openlord(false);

			} else {
				palying.time[0].setText("抢地主");
				palying.time[0].setVisible(true);
				setlord(0);// 设定地主
				openlord(true);
				second(3);
				palying.playerList[0].addAll(palying.lordList);
				PlayUtil.order(palying.playerList[0]);
				PlayUtil.rePosition(palying, palying.playerList[0], 0);
				openlord(false);

			}
		}
		
		// 选完地主后 关闭地主按钮		
		palying.landlord[0].setVisible(false);
		palying.landlord[1].setVisible(false);
		turnOn(false);
		for (int i = 0; i < 3; i++)
		{
			palying.time[i].setText("不要");
			palying.time[i].setVisible(false);
		}
		
		/**
		 * 开始正式游戏，根据地主不同顺序不同
		 */
		palying.turn=palying.lordFlag;
		while (true) {
			
			if(palying.turn==1) //我
			{
				turnOn(true);// 出牌按钮 --我出牌
				timeWait(30, 1);// 我自己的定时器
				turnOn(false);//选完关闭
				palying.turn=(palying.turn+1)%3;
				if(win())//判断输赢
				{
//					this.palying.container.removeAll();
//					Runnable thread = new Runnable() {				
//						@Override
//						public void run() {
//							// TODO Auto-generated method stub
//							palying.InitGame();
//						}
//					};				
//					Thread t = new Thread(thread);
//					t.start();
					break;
				}
			}
			if (palying.turn==0) 
			{
				computer0();
				palying.turn=(palying.turn+1)%3;
				if(win())//判断输赢
					break;
			}
			if(palying.turn==2)
			{
				computer2();
				palying.turn=(palying.turn+1)%3;
				if(win())//判断输赢
					break;
			}
		}
	}

	/**
	 * 等待i秒
	 * @param i
	 */
	public void second(int i) {
		try {
			Thread.sleep(i * 1000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/**
	 * 地主牌翻看
	 * @param is
	 */
	public void openlord(boolean is) {
		for (int i = 0; i < 3; i++) {
			if (is)
				palying.lordList.get(i).turnFront(); // 地主牌翻看
			else {
				palying.lordList.get(i).turnRear(); // 地主牌闭合
			}
			palying.lordList.get(i).canClick = true;// 可被点击
		}
	}

	/**
	 * 设定地主
	 * @param i
	 */
	public void setlord(int i) {
		Point point = new Point();
		if (i == 1)// 我是地主
		{
			point.x = 80;
			point.y = 430;
			palying.lordFlag = 1;// 设定地主
		}
		if (i == 0) {
			point.x = 80;
			point.y = 20;
			palying.lordFlag = 0;
		}
		if (i == 2) {
			point.x = 700;
			point.y = 20;
			palying.lordFlag = 2;
		}
		palying.lord.setLocation(point);
		palying.lord.setVisible(true);
	}

	/**
	 * 打开出牌按钮
	 * @param flag
	 */
	public void turnOn(boolean flag) {
		palying.publishCard[0].setVisible(flag);
		palying.publishCard[1].setVisible(flag);
	}

	/**
	 * 电脑0走牌(我代表1)
	 */
	public void computer0() {
		timeWait(1, 0); // 定时
		ShowCard(0); // 出牌
		
	}

	/**
	 * 电脑2走牌(我代表1)
	 */
	public void computer2() {
		timeWait(1, 2); // 定时
		ShowCard(2); // 出牌
		
	}

	/**
	 * 走牌
	 * @param role
	 */
	public void ShowCard(int role) {
		Model model = PlayUtil.getModel(palying.playerList[role]);
		// 待走的牌
		List<String> list = new ArrayList();
		// 如果是主动出牌
		if (palying.time[(role + 1) % 3].getText().equals("不要")
				&& palying.time[(role + 2) % 3].getText().equals("不要")) {
			// 有单出单 (除开3带，飞机能带的单牌)
			if (model.a1.size() > (model.a111222.size() * 2 + model.a3.size())) {
				list.add(model.a1.get(model.a1.size() - 1));
			}// 有对子出对子 (除开3带，飞机)
			else if (model.a2.size() > (model.a111222.size() * 2 + model.a3
					.size())) {
				list.add(model.a2.get(model.a2.size() - 1));
			}// 有顺子出顺子
			else if (model.a123.size() > 0) {
				list.add(model.a123.get(model.a123.size() - 1));
			}// 有3带就出3带，没有就出光3
			else if (model.a3.size() > 0) {
				// 3带单,且非关键时刻不能带王，2
				if (model.a1.size() > 0) {
					list.add(model.a1.get(model.a1.size() - 1));
				}// 3带对
				else if (model.a2.size() > 0) {
					list.add(model.a2.get(model.a2.size() - 1));
				}
				list.add(model.a3.get(model.a3.size() - 1));
			}// 有双顺出双顺
			else if (model.a112233.size() > 0) {
				list.add(model.a112233.get(model.a112233.size() - 1));
			}// 有飞机出飞机
			else if (model.a111222.size() > 0) {
				String name[] = model.a111222.get(0).split(",");
				// 带单
				if (name.length / 3 <= model.a1.size()) {
					list.add(model.a111222.get(model.a111222.size() - 1));
					for (int i = 0; i < name.length / 3; i++)
						list.add(model.a1.get(i));
				} else if (name.length / 3 <= model.a2.size())// 带双
				{
					list.add(model.a111222.get(model.a111222.size() - 1));
					for (int i = 0; i < name.length / 3; i++)
						list.add(model.a2.get(i));
				}
				// 有炸弹出炸弹
			} else if (model.a4.size() > 0) {
				// 4带2,1
				int sizea1 = model.a1.size();
				int sizea2 = model.a2.size();
				if (sizea1 >= 2) {
					list.add(model.a1.get(sizea1 - 1));
					list.add(model.a1.get(sizea1 - 2));
					list.add(model.a4.get(0));
				
				} else if (sizea2 >= 2) {
					list.add(model.a2.get(sizea1 - 1));
					list.add(model.a2.get(sizea1 - 2));
					list.add(model.a4.get(0));
					
				} else {// 直接炸
					list.add(model.a4.get(0));
					
				}

			}
		}// 如果是跟牌
		else {
			List<Card> player = palying.currentList[(role + 2) % 3].size() > 0 
					? palying.currentList[(role + 2) % 3]
					: palying.currentList[(role + 1) % 3];
			
			CardType cType=PlayUtil.jugdeType(player);
			//如果是单牌
			if(cType==CardType.c1)
			{
				AI_1(model.a1, player, list, role);
			}//如果是对子
			else if(cType==CardType.c2)
			{
				AI_1(model.a2, player, list, role);
			}//3带
			else if(cType==CardType.c3)
			{
				AI_1(model.a3, player, list, role);
			}//炸弹
			else if(cType==CardType.c4)
			{
				AI_1(model.a4, player, list, role);
			}//如果是3带1
			else if(cType==CardType.c31){
				 //偏家 涉及到拆牌
				//if((role+1)%3==main.dizhuFlag)
					AI_2(model.a3, model.a1, player, list, role);
			}//如果是3带2
			else if(cType==CardType.c32){
				 //偏家
				//if((role+1)%3==main.dizhuFlag)
					AI_2(model.a3, model.a2, player, list, role);
			}//如果是4带11
			else if(cType==CardType.c411){
					AI_5(model.a4, model.a1, player, list, role);
			}
			//如果是4带22
			else if(cType==CardType.c422){
					AI_5(model.a4, model.a2, player, list, role);
			}
			//顺子
			else if(cType==CardType.c123){
				AI_3(model.a123, player, list, role);
			}
			//双顺
			else if(cType==CardType.c1122){
				AI_3(model.a112233, player, list, role);
			}
			//飞机带单
			else if(cType==CardType.c11122234){
				AI_4(model.a111222,model.a1, player, list, role);
			}
			//飞机带对
			else if(cType==CardType.c1112223344){
				AI_4(model.a111222,model.a2, player, list, role);
			}
			//炸弹
			if(list.size()==0)
			{
				int len4=model.a4.size();
				if(len4>0)
					list.add(model.a4.get(len4-1));
			}
		}

		/**
		 * 定位出牌
		 */
		palying.currentList[role].clear();
		if (list.size() > 0) {
			Point point = new Point();
			if (role == 0)
				point.x = 200;
			if (role == 2)
				point.x = 550;
			point.y = (400 / 2) - (list.size() + 1) * 15 / 2;// 屏幕中部
			// 将name转换成Card
			for (int i = 0, len = list.size(); i < len; i++) {
				List<Card> cards = getCardByName(palying.playerList[role],
						list.get(i));
				for (Card card : cards) {
					PlayUtil.move(card, card.getLocation(), point);
					point.y += 15;
					palying.currentList[role].add(card);
					palying.playerList[role].remove(card);
				}
			}
			PlayUtil.rePosition(palying, palying.playerList[role], role);
		} else {
			palying.time[role].setVisible(true);
			palying.time[role].setText("不要");
		}
		for(Card card:palying.currentList[role])
			card.turnFront();
	}

	/**
	 * 按name获得Card，方便从Model取出
	 * @param list
	 * @param n
	 * @return
	 */
	public List getCardByName(List<Card> list, String n) {
		String[] name = n.split(",");
		List cardsList = new ArrayList<Card>();
		int j = 0;
		for (int i = 0, len = list.size(); i < len; i++) {
			if (j < name.length && list.get(i).name.equals(name[j])) {
				cardsList.add(list.get(i));
				i = 0;
				j++;
			}
		}
		return cardsList;
	}

	/**
	 * 顺子
	 * @param model
	 * @param player
	 * @param list
	 * @param role
	 */
	public void AI_3(List<String> model,List<Card> player,List<String> list,int role){
		
		for(int i=0,len=model.size();i<len;i++)
		{
			String []s=model.get(i).split(",");
			if(s.length==player.size()&&getValueInt(model.get(i))>PlayUtil.getValue(player.get(0)))
			{
				list.add(model.get(i));
				return;
			}
		}
	}

	/**
	 * 飞机带单，双
	 * @param model1
	 * @param model2
	 * @param player
	 * @param list
	 * @param role
	 */
	public void AI_4(List<String> model1,List<String> model2,List<Card> player,List<String> list,int role){
		//排序按重复数
		player=PlayUtil.getOrder2(player);
		int len1=model1.size();
		int len2=model2.size();
		
		if(len1<1 || len2<1)
			return;
		for(int i=0;i<len1;i++){
			String []s=model1.get(i).split(",");
			String []s2=model2.get(0).split(",");
			if((s.length/3<=len2)&&(s.length*(3+s2.length)==player.size())&&getValueInt(model1.get(i))>PlayUtil.getValue(player.get(0)))
			{
				list.add(model1.get(i));
				for(int j=1;j<=s.length/3;j++)
					list.add(model2.get(len2-j));
			}
		}
	}

	/**
	 * 4带1，2
	 * @param model1
	 * @param model2
	 * @param player
	 * @param list
	 * @param role
	 */
	public void AI_5(List<String> model1,List<String> model2,List<Card> player,List<String> list,int role){
		//排序按重复数
		player=PlayUtil.getOrder2(player);
		int len1=model1.size();
		int len2=model2.size();
		
		if(len1<1 || len2<2)
			return;
		for(int i=0;i<len1;i++){
			if(getValueInt(model1.get(i))>PlayUtil.getValue(player.get(0)))
			{
				list.add(model1.get(i));
				for(int j=1;j<=2;j++)
					list.add(model2.get(len2-j));
			}
		}
	}

	/**
	 * 单牌，对子，3个，4个,通用
	 * @param model
	 * @param player
	 * @param list
	 * @param role
	 */
	public void AI_1(List<String> model,List<Card> player,List<String> list,int role){
		//顶家
		if((role+1)%3==palying.lordFlag)
		{
			
			for(int i=0,len=model.size();i<len;i++)
			{
				if(getValueInt(model.get(i))>PlayUtil.getValue(player.get(0)))
				{
					list.add(model.get(i));
					break;
				}
			}
		}else {//偏家
			
			for(int len=model.size(),i=len-1;i>=0;i--)
			{
				if(getValueInt(model.get(i))>PlayUtil.getValue(player.get(0)))
				{
					list.add(model.get(i));
					break;
				}
			}
		}
	}

	/**
	 * 3带1,2,4带1,2
	 * @param model1
	 * @param model2
	 * @param player
	 * @param list
	 * @param role
	 */
	public void AI_2(List<String> model1,List<String> model2,List<Card> player,List<String> list,int role){
		//model1是主牌,model2是带牌,player是玩家出的牌,,list是准备回的牌
		//排序按重复数
		player=PlayUtil.getOrder2(player);
		int len1=model1.size();
		int len2=model2.size();
		//如果有王直接炸了
		if(len1>0&&model1.get(0).length()<10)
		{
			list.add(model1.get(0));
			System.out.println("王炸");
			return;
		}
		if(len1<1 || len2<1)
			return;
		for(int len=len1,i=len-1;i>=0;i--)
		{	
			if(getValueInt(model1.get(i))>PlayUtil.getValue(player.get(0)))
			{
				list.add(model1.get(i));
				break;
			}
		} 
		list.add(model2.get(len2-1));
		if(list.size()<2)
			list.clear();
	}

	/**
	 * 延时，模拟时钟
	 * @param n
	 * @param player
	 */
	public void timeWait(int n, int player) {

		if (palying.currentList[player].size() > 0)
			PlayUtil.hideCards(palying.currentList[player]);
		if (player == 1)// 如果是我，10秒到后直接下一家出牌
		{
			int i = n;

			while (palying.nextPlayer == false && i >= 0) {
				// main.container.setComponentZOrder(main.time[player], 0);
				palying.time[player].setText("倒计时:" + i);
				palying.time[player].setVisible(true);
				second(1);
				i--;
			}
			if (i == -1) {
				palying.time[player].setText("超时");
			}
			palying.nextPlayer = false;
		} else {
			for (int i = n; i >= 0; i--) {
				second(1);
				// main.container.setComponentZOrder(main.time[player], 0);
				palying.time[player].setText("倒计时:" + i);
				palying.time[player].setVisible(true);
			}
		}
		palying.time[player].setVisible(false);
	}

	/**
	 * 通过name估值
	 * @param n
	 * @return
	 */
	public  int getValueInt(String n){
		String name[]=n.split(",");
		String s=name[0];
		int i=Integer.parseInt(s.substring(2, s.length()));
		if(s.substring(0, 1).equals("5"))
			i+=3;
		if(s.substring(2, s.length()).equals("1")||s.substring(2, s.length()).equals("2"))
			i+=13;
		return i;
	}

	/**
	 * 判断输赢
	 * @return
	 */
	public boolean win(){
		String score;
		score = Playing.getScores();
		int pscore = Integer.valueOf(score);
		
		users = LoginAction.getUsername();
		scorePro = new Properties();
		scorefile = new File("Score.properties");		
		FileUtil.loadPro(scorePro, scorefile);		
		
		for(int i=0;i<3;i++){
			if(palying.playerList[i].size()==0)
			{
				String s;
				if(i==1)
				{
					s="恭喜你，胜利了!你的分数加3";
					pscore += 3;					
					scorePro.setProperty(users, String.valueOf(pscore));
					try {
						scorePro.store(new FileOutputStream(scorefile), "plus 3 scores");
					} catch (IOException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}else {
					s="很遗憾，你输了!你的分数减3";
					pscore -= 3;
					scorePro.setProperty(users, String.valueOf(pscore));
					try {
						scorePro.store(new FileOutputStream(scorefile), "subtract 3 scores");
					} catch (IOException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				JOptionPane.showMessageDialog(palying, s);
				this.palying.container.removeAll();
				Runnable thread = new Runnable() {				
					@Override
					public void run() {
						// TODO Auto-generated method stub
						palying.InitGame();
					}
				};				
				Thread t = new Thread(thread);
				t.start();
				return true;
			}
		}
		return false;
	}

	/**
	 * 以下是get,set方法
	 * @return
	 */
	public boolean isRun() {
		return isRun;
	}

	public void setRun(boolean isRun) {
		this.isRun = isRun;
	}
}
